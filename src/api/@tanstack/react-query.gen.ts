// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { createBlog, createCategory, createCourse, createTag, deleteBlog, deleteCategory, deleteCourse, deleteMedia, deleteMessage, deleteTag, getAllCategories, getAllCourses, getAllMedia, getAllMessages, getAllTags, getBlogBySlug, getCourseBySlug, getMe, getMessageById, getPublishedBlogs, health, login, logout, type Options, refreshToken, root, submitContactForm, updateBlog, updateCourse, updateStatus, uploadMedia } from '../sdk.gen';
import type { CreateBlogData, CreateBlogResponse, CreateCategoryData, CreateCategoryResponse, CreateCourseData, CreateCourseResponse, CreateTagData, CreateTagResponse, DeleteBlogData, DeleteBlogResponse, DeleteCategoryData, DeleteCategoryResponse, DeleteCourseData, DeleteCourseResponse, DeleteMediaData, DeleteMediaResponse, DeleteMessageData, DeleteMessageResponse, DeleteTagData, DeleteTagResponse, GetAllCategoriesData, GetAllCategoriesResponse, GetAllCoursesData, GetAllCoursesResponse, GetAllMediaData, GetAllMediaResponse, GetAllMessagesData, GetAllMessagesResponse, GetAllTagsData, GetAllTagsResponse, GetBlogBySlugData, GetBlogBySlugResponse, GetCourseBySlugData, GetCourseBySlugResponse, GetMeData, GetMeResponse, GetMessageByIdData, GetMessageByIdResponse, GetPublishedBlogsData, GetPublishedBlogsResponse, HealthData, HealthResponse, LoginData, LogoutData, LogoutResponse, RefreshTokenData, RefreshTokenResponse, RootData, RootResponse, SubmitContactFormData, SubmitContactFormResponse, UpdateBlogData, UpdateBlogResponse, UpdateCourseData, UpdateCourseResponse, UpdateStatusData, UpdateStatusResponse, UploadMediaData, UploadMediaResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getAllTagsQueryKey = (options?: Options<GetAllTagsData>) => createQueryKey('getAllTags', options);

/**
 * Get all tags
 */
export const getAllTagsOptions = (options?: Options<GetAllTagsData>) => queryOptions<GetAllTagsResponse, DefaultError, GetAllTagsResponse, ReturnType<typeof getAllTagsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllTags({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllTagsQueryKey(options)
});

/**
 * Create a new tag
 */
export const createTagMutation = (options?: Partial<Options<CreateTagData>>): UseMutationOptions<CreateTagResponse, DefaultError, Options<CreateTagData>> => {
    const mutationOptions: UseMutationOptions<CreateTagResponse, DefaultError, Options<CreateTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a tag
 */
export const deleteTagMutation = (options?: Partial<Options<DeleteTagData>>): UseMutationOptions<DeleteTagResponse, DefaultError, Options<DeleteTagData>> => {
    const mutationOptions: UseMutationOptions<DeleteTagResponse, DefaultError, Options<DeleteTagData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTag({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Upload media file
 */
export const uploadMediaMutation = (options?: Partial<Options<UploadMediaData>>): UseMutationOptions<UploadMediaResponse, DefaultError, Options<UploadMediaData>> => {
    const mutationOptions: UseMutationOptions<UploadMediaResponse, DefaultError, Options<UploadMediaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadMedia({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllMediaQueryKey = (options?: Options<GetAllMediaData>) => createQueryKey('getAllMedia', options);

/**
 * Get all media for the current user
 */
export const getAllMediaOptions = (options?: Options<GetAllMediaData>) => queryOptions<GetAllMediaResponse, DefaultError, GetAllMediaResponse, ReturnType<typeof getAllMediaQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllMedia({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllMediaQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getAllMediaInfiniteQueryKey = (options?: Options<GetAllMediaData>): QueryKey<Options<GetAllMediaData>> => createQueryKey('getAllMedia', options, true);

/**
 * Get all media for the current user
 */
export const getAllMediaInfiniteOptions = (options?: Options<GetAllMediaData>) => infiniteQueryOptions<GetAllMediaResponse, DefaultError, InfiniteData<GetAllMediaResponse>, QueryKey<Options<GetAllMediaData>>, number | Pick<QueryKey<Options<GetAllMediaData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllMediaData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllMedia({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllMediaInfiniteQueryKey(options)
});

/**
 * Delete media by ID
 */
export const deleteMediaMutation = (options?: Partial<Options<DeleteMediaData>>): UseMutationOptions<DeleteMediaResponse, DefaultError, Options<DeleteMediaData>> => {
    const mutationOptions: UseMutationOptions<DeleteMediaResponse, DefaultError, Options<DeleteMediaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMedia({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const rootQueryKey = (options?: Options<RootData>) => createQueryKey('root', options);

export const rootOptions = (options?: Options<RootData>) => queryOptions<RootResponse, DefaultError, RootResponse, ReturnType<typeof rootQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await root({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: rootQueryKey(options)
});

export const healthQueryKey = (options?: Options<HealthData>) => createQueryKey('health', options);

export const healthOptions = (options?: Options<HealthData>) => queryOptions<HealthResponse, DefaultError, HealthResponse, ReturnType<typeof healthQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await health({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthQueryKey(options)
});

export const getAllCoursesQueryKey = (options?: Options<GetAllCoursesData>) => createQueryKey('getAllCourses', options);

/**
 * Get all courses with pagination
 */
export const getAllCoursesOptions = (options?: Options<GetAllCoursesData>) => queryOptions<GetAllCoursesResponse, DefaultError, GetAllCoursesResponse, ReturnType<typeof getAllCoursesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllCourses({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllCoursesQueryKey(options)
});

export const getAllCoursesInfiniteQueryKey = (options?: Options<GetAllCoursesData>): QueryKey<Options<GetAllCoursesData>> => createQueryKey('getAllCourses', options, true);

/**
 * Get all courses with pagination
 */
export const getAllCoursesInfiniteOptions = (options?: Options<GetAllCoursesData>) => infiniteQueryOptions<GetAllCoursesResponse, DefaultError, InfiniteData<GetAllCoursesResponse>, QueryKey<Options<GetAllCoursesData>>, number | Pick<QueryKey<Options<GetAllCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllCoursesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllCourses({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllCoursesInfiniteQueryKey(options)
});

/**
 * Create a new course
 */
export const createCourseMutation = (options?: Partial<Options<CreateCourseData>>): UseMutationOptions<CreateCourseResponse, DefaultError, Options<CreateCourseData>> => {
    const mutationOptions: UseMutationOptions<CreateCourseResponse, DefaultError, Options<CreateCourseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCourse({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCourseBySlugQueryKey = (options: Options<GetCourseBySlugData>) => createQueryKey('getCourseBySlug', options);

/**
 * Get course by slug
 */
export const getCourseBySlugOptions = (options: Options<GetCourseBySlugData>) => queryOptions<GetCourseBySlugResponse, DefaultError, GetCourseBySlugResponse, ReturnType<typeof getCourseBySlugQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCourseBySlug({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCourseBySlugQueryKey(options)
});

/**
 * Delete a course
 */
export const deleteCourseMutation = (options?: Partial<Options<DeleteCourseData>>): UseMutationOptions<DeleteCourseResponse, DefaultError, Options<DeleteCourseData>> => {
    const mutationOptions: UseMutationOptions<DeleteCourseResponse, DefaultError, Options<DeleteCourseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCourse({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a course
 */
export const updateCourseMutation = (options?: Partial<Options<UpdateCourseData>>): UseMutationOptions<UpdateCourseResponse, DefaultError, Options<UpdateCourseData>> => {
    const mutationOptions: UseMutationOptions<UpdateCourseResponse, DefaultError, Options<UpdateCourseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCourse({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllMessagesQueryKey = (options?: Options<GetAllMessagesData>) => createQueryKey('getAllMessages', options);

/**
 * Get all contact messages (Admin only)
 */
export const getAllMessagesOptions = (options?: Options<GetAllMessagesData>) => queryOptions<GetAllMessagesResponse, DefaultError, GetAllMessagesResponse, ReturnType<typeof getAllMessagesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllMessages({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllMessagesQueryKey(options)
});

export const getAllMessagesInfiniteQueryKey = (options?: Options<GetAllMessagesData>): QueryKey<Options<GetAllMessagesData>> => createQueryKey('getAllMessages', options, true);

/**
 * Get all contact messages (Admin only)
 */
export const getAllMessagesInfiniteOptions = (options?: Options<GetAllMessagesData>) => infiniteQueryOptions<GetAllMessagesResponse, DefaultError, InfiniteData<GetAllMessagesResponse>, QueryKey<Options<GetAllMessagesData>>, number | Pick<QueryKey<Options<GetAllMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetAllMessagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllMessages({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllMessagesInfiniteQueryKey(options)
});

/**
 * Submit a contact us form
 */
export const submitContactFormMutation = (options?: Partial<Options<SubmitContactFormData>>): UseMutationOptions<SubmitContactFormResponse, DefaultError, Options<SubmitContactFormData>> => {
    const mutationOptions: UseMutationOptions<SubmitContactFormResponse, DefaultError, Options<SubmitContactFormData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await submitContactForm({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a contact message (Admin only)
 */
export const deleteMessageMutation = (options?: Partial<Options<DeleteMessageData>>): UseMutationOptions<DeleteMessageResponse, DefaultError, Options<DeleteMessageData>> => {
    const mutationOptions: UseMutationOptions<DeleteMessageResponse, DefaultError, Options<DeleteMessageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteMessage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMessageByIdQueryKey = (options: Options<GetMessageByIdData>) => createQueryKey('getMessageById', options);

/**
 * Get a contact message by ID (Admin only)
 */
export const getMessageByIdOptions = (options: Options<GetMessageByIdData>) => queryOptions<GetMessageByIdResponse, DefaultError, GetMessageByIdResponse, ReturnType<typeof getMessageByIdQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMessageById({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMessageByIdQueryKey(options)
});

/**
 * Update a contact message status (Admin only)
 */
export const updateStatusMutation = (options?: Partial<Options<UpdateStatusData>>): UseMutationOptions<UpdateStatusResponse, DefaultError, Options<UpdateStatusData>> => {
    const mutationOptions: UseMutationOptions<UpdateStatusResponse, DefaultError, Options<UpdateStatusData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateStatus({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllCategoriesQueryKey = (options?: Options<GetAllCategoriesData>) => createQueryKey('getAllCategories', options);

/**
 * Get all categories
 */
export const getAllCategoriesOptions = (options?: Options<GetAllCategoriesData>) => queryOptions<GetAllCategoriesResponse, DefaultError, GetAllCategoriesResponse, ReturnType<typeof getAllCategoriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllCategories({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllCategoriesQueryKey(options)
});

/**
 * Create a new category
 */
export const createCategoryMutation = (options?: Partial<Options<CreateCategoryData>>): UseMutationOptions<CreateCategoryResponse, DefaultError, Options<CreateCategoryData>> => {
    const mutationOptions: UseMutationOptions<CreateCategoryResponse, DefaultError, Options<CreateCategoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCategory({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a category
 */
export const deleteCategoryMutation = (options?: Partial<Options<DeleteCategoryData>>): UseMutationOptions<DeleteCategoryResponse, DefaultError, Options<DeleteCategoryData>> => {
    const mutationOptions: UseMutationOptions<DeleteCategoryResponse, DefaultError, Options<DeleteCategoryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCategory({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPublishedBlogsQueryKey = (options?: Options<GetPublishedBlogsData>) => createQueryKey('getPublishedBlogs', options);

/**
 * Get all published blogs (public endpoint)
 */
export const getPublishedBlogsOptions = (options?: Options<GetPublishedBlogsData>) => queryOptions<GetPublishedBlogsResponse, DefaultError, GetPublishedBlogsResponse, ReturnType<typeof getPublishedBlogsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPublishedBlogs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPublishedBlogsQueryKey(options)
});

export const getPublishedBlogsInfiniteQueryKey = (options?: Options<GetPublishedBlogsData>): QueryKey<Options<GetPublishedBlogsData>> => createQueryKey('getPublishedBlogs', options, true);

/**
 * Get all published blogs (public endpoint)
 */
export const getPublishedBlogsInfiniteOptions = (options?: Options<GetPublishedBlogsData>) => infiniteQueryOptions<GetPublishedBlogsResponse, DefaultError, InfiniteData<GetPublishedBlogsResponse>, QueryKey<Options<GetPublishedBlogsData>>, number | Pick<QueryKey<Options<GetPublishedBlogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPublishedBlogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPublishedBlogs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPublishedBlogsInfiniteQueryKey(options)
});

/**
 * Create a new blog
 */
export const createBlogMutation = (options?: Partial<Options<CreateBlogData>>): UseMutationOptions<CreateBlogResponse, DefaultError, Options<CreateBlogData>> => {
    const mutationOptions: UseMutationOptions<CreateBlogResponse, DefaultError, Options<CreateBlogData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBlog({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBlogBySlugQueryKey = (options: Options<GetBlogBySlugData>) => createQueryKey('getBlogBySlug', options);

/**
 * Get blog by slug (public endpoint)
 */
export const getBlogBySlugOptions = (options: Options<GetBlogBySlugData>) => queryOptions<GetBlogBySlugResponse, DefaultError, GetBlogBySlugResponse, ReturnType<typeof getBlogBySlugQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBlogBySlug({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBlogBySlugQueryKey(options)
});

/**
 * Delete a blog
 */
export const deleteBlogMutation = (options?: Partial<Options<DeleteBlogData>>): UseMutationOptions<DeleteBlogResponse, DefaultError, Options<DeleteBlogData>> => {
    const mutationOptions: UseMutationOptions<DeleteBlogResponse, DefaultError, Options<DeleteBlogData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBlog({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a blog
 */
export const updateBlogMutation = (options?: Partial<Options<UpdateBlogData>>): UseMutationOptions<UpdateBlogResponse, DefaultError, Options<UpdateBlogData>> => {
    const mutationOptions: UseMutationOptions<UpdateBlogResponse, DefaultError, Options<UpdateBlogData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBlog({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Login user
 */
export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<unknown, DefaultError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<LoginData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await login({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<LogoutResponse, DefaultError, Options<LogoutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await logout({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Refresh access token
 */
export const refreshTokenMutation = (options?: Partial<Options<RefreshTokenData>>): UseMutationOptions<RefreshTokenResponse, DefaultError, Options<RefreshTokenData>> => {
    const mutationOptions: UseMutationOptions<RefreshTokenResponse, DefaultError, Options<RefreshTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await refreshToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMeQueryKey = (options?: Options<GetMeData>) => createQueryKey('getMe', options);

/**
 * Get current user profile
 */
export const getMeOptions = (options?: Options<GetMeData>) => queryOptions<GetMeResponse, DefaultError, GetMeResponse, ReturnType<typeof getMeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMe({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMeQueryKey(options)
});
